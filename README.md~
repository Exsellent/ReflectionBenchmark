# **Проект 5: Измерение производительности**

Проект направлен на изучение и сравнение производительности различных методов вызова
через **Java Reflection API** и альтернативных подходов.

---

## **Цель проекта**

Реализовать и провести бенчмарк-тесты для **четырёх способов вызова метода**:

1. **Прямой доступ** к методу.
2. Использование **`java.lang.reflect.Method`**.
3. Использование **`java.lang.invoke.MethodHandles`**.
4. Использование **`java.lang.invoke.LambdaMetafactory`**.

---

## **Функциональные требования**

1. Реализовать **бенчмарк-тест** для каждого варианта метода.
2. Использовать **профильный фреймворк** для замера производительности:
    - Java: **JMH** (Java Microbenchmark Harness).
3. Провести замеры, получить финальную таблицу результатов.

---

## **Нефункциональные требования**

1. **Опубликовать финальную таблицу результатов запуска тестов**.
2. Минимизировать фоновую нагрузку на компьютер при проведении замеров.
3. Время выполнения тестов должно быть увеличено для получения корректных данных (порядка
нескольких минут).

---

## **Структура проекта**

Проект организован с использованием **Apache Maven** и включает следующие
ключевые компоненты:

```
.
├── pom.xml                              # Конфигурация Maven и зависимости
├── src/
│   ├── main/
│   │   ├── java/
│   │   │   └── backend/
│   │   │       ├── academy/
│   │   │       │   ├── Main.java        # Точка входа
│   │   │       │   └── PerformanceMeasurement/
│   │   │       │       ├── benchmark/
│   │   │       │       │   ├── ReflectionBenchmark.java   # Бенчмарк-тесты
│   │   │       │       │   └── BenchmarkResultsCollector.java # Сбор результатов
│   │   │       │       └── model/
│   │   │       │           └── Student.java   # Тестируемый класс
│   ├── test/                                # Тесты для проверки корректности
│
├── checkstyle.xml                           # Конфигурация Checkstyle
├── pmd.xml                                  # Конфигурация PMD
└── benchmark_results.txt                    # Финальные результаты замеров
```

---

## **Тестируемый класс**

Пример целевого класса:

```java
public record Student(String name, String surname) {}
```

---

## **Бенчмарк-тесты**

Тесты измеряют производительность четырёх методов вызова:

```java
@BenchmarkMode(Mode.AverageTime)
@OutputTimeUnit(TimeUnit.NANOSECONDS)
@State(Scope.Thread)
public class ReflectionBenchmark {
    private Student student;
    private Method method;

    @Setup
    public void setup() throws NoSuchMethodException {
        student = new Student("Alexander", "Biryukov");
        method = Student.class.getDeclaredMethod("name");
        method.setAccessible(true);
    }

    @Benchmark
    public void directAccess(Blackhole bh) {
        bh.consume(student.name());
    }

    @Benchmark
    public void reflectionAccess(Blackhole bh) throws Exception {
        bh.consume(method.invoke(student));
    }
}
```

---

## **Запуск и сборка проекта**

Для запуска и тестирования проекта требуется **Java 22** и **Maven 3.8.8+**.

### **1. Сборка проекта**

Для сборки и проверки корректности выполнения:

```bash
mvn clean verify
```

### **2. Запуск бенчмарк-тестов**

Запуск тестов с помощью JMH:

```bash
mvn exec:java -Dexec.mainClass="backend.academy.PerformanceMeasurement.benchmark.ReflectionBenchmark"
```

### **3. Сбор результатов**

Для сборки и сохранения таблицы с результатами:

```bash
mvn exec:java -Dexec.mainClass="backend.academy.PerformanceMeasurement.benchmark.BenchmarkResultsCollector"
```

Результаты будут сохранены в файл **`benchmark_results.txt`**.

---

## **Пример финальной таблицы результатов**

```
Benchmark                                Mode       Cnt   Score      Error      Units     
=====================================================================================
directAccess                             avgt       1     0.620      0.000      ns/op     
lambdaMetafactoryAccess                  avgt       1     0.907      0.000      ns/op     
methodHandleAccess                       avgt       1     5.108      0.000      ns/op     
reflectionAccess                         avgt       1     7.098      0.000      ns/op     
```

---

## **Анализ текущих результатов**
    1. Прямой вызов метода (directAccess):

    Абсолютный лидер по скорости (0.620 ns/op).
    Максимальная производительность достигается за счет:
        Прямой компиляции кода.
        Полной оптимизации JIT-компилятором.
        Отсутствия дополнительных накладных расходов (например, динамического поиска методов или проверки доступности).
        Эталонный вариант для сравнительного анализа производительности.

   2. ЛямбдаМетафабрика (lambdaMetafactoryAccess):

       Близок к прямому вызову (0.907 ns/op).
       Преимущества:
           Незначительный overhead относительно прямого вызова.
           Гибкость при работе с методами (возможность передачи методов в виде функциональных интерфейсов для дальнейшего
           использования).
           Возможность динамического создания функциональных интерфейсов, что полезно для гибкой и быстрой генерации
           обработчиков во время выполнения.
           Оптимальный выбор для сценариев, требующих динамичности и гибкости.

   3. Обработчик метода (methodHandleAccess):

        Существенно медленнее прямого вызова (5.108 ns/op).
        Причины снижения производительности:
            Динамическое разрешение метода (определение адреса метода во время выполнения).
            Дополнительные проверки типов и доступа перед вызовом.
            Overhead механизма поиска и привязки метода, особенно для нестандартных сценариев.

   4. Рефлексия (reflectionAccess):

       Самый ресурсоемкий механизм вызова (7.098 ns/op).
       Характеристики:
           Максимальные накладные расходы (поиск метода, проверка доступа и выполнение вызова).
           Динамическое определение и вызов метода на основе рефлексии.
           Значительные проверки типов, доступности и корректности вызова, которые добавляют задержки.
       Наименее эффективный способ вызова метода и его следует избегать при критических требованиях к производительности.

---

## **Многократный запуск тестов**

Если запустить тесты несколько раз, результаты могут немного варьироваться из-за следующих факторов:

    1. JIT-компиляция (Just-In-Time): JVM оптимизирует код по мере выполнения. При повторных запусках производительность
может улучшиться из-за дополнительных оптимизаций.
    2. Нагрузка на систему: фоновая активность операционной системы или других программ может влиять на результаты замеров.
    3. Кэширование данных: часть данных или методов может быть закэширована JVM, что снижает время доступа и улучшает
производительность.

---

## **Практические рекомендации**

На основе проведенных замеров производительности и анализа результатов можно сделать следующие рекомендации:

    Для высокопроизводительных участков кода:
    Необходимо использовать прямой вызов методов, так как он обеспечивает максимальную скорость и минимальные
    накладные расходы.

    LambdaMetafactory:
    Является хорошим компромиссом между производительностью и гибкостью. Рекомендуется для динамического вызова методов
    в сценариях, где требуется создавать обработчики во время выполнения.

    Следует избегать частого использования рефлексии:
    В критически важных секциях кода, где важна производительность, рефлексия должна использоваться с осторожностью,
    так как она имеет высокие накладные расходы и является самым медленным способом вызова.

## **Команды для анализа и тестирования**

1. **Компиляция проекта:**
   ```bash
   mvn compile
   ```

2. **Запуск тестов:**
   ```bash
   mvn test
   ```

3. **Запуск линтеров:**
   ```bash
   mvn checkstyle:check pmd:check spotbugs:check
   ```

4. **Вывод дерева зависимостей:**
   ```bash
   mvn dependency:tree
   ```

---

## **Полезные ресурсы**

- [JMH Samples](https://github.com/openjdk/jmh/tree/master/jmh-samples)
- [Java Reflection](https://blogs.oracle.com/javamagazine/post/java-reflection-introduction)
- [Документация по Maven](https://maven.apache.org/guides/index.html)
- [Java 22 API](https://docs.oracle.com/en/java/javase/22/docs/api/index.html)

---

## **Заключение**

В проекте реализованы и протестированы четыре различных способа вызова методов в Java
с использованием JMH. Результаты замеров производительности позволяют оценить разницу
в скорости и выбрать оптимальный подход для решения задач в реальных проектах.

---
