# **Проект 5: Измерение производительности**

Проект направлен на изучение и сравнение производительности различных методов вызова
через **Java Reflection API** и альтернативных подходов.

---

## **Цель проекта**

Реализовать и провести бенчмарк-тесты для **четырёх способов вызова метода**:

1. **Прямой доступ** к методу.
2. Использование **`java.lang.reflect.Method`**.
3. Использование **`java.lang.invoke.MethodHandles`**.
4. Использование **`java.lang.invoke.LambdaMetafactory`**.

---

## **Функциональные требования**

1. Реализовать **бенчмарк-тест** для каждого варианта метода.
2. Использовать **профильный фреймворк** для замера производительности:
    - Java: **JMH** (Java Microbenchmark Harness).
3. Провести замеры, получить финальную таблицу результатов.

---

## **Нефункциональные требования**

1. **Опубликовать финальную таблицу результатов запуска тестов**.
2. **Минимизировать фоновую нагрузку на компьютер при проведении замеров**.
3. **Время выполнения тестов должно быть увеличено для получения корректных данных (порядка
нескольких минут)**.

---

## **Структура проекта**

Проект организован с использованием **Apache Maven** и включает следующие ключевые компоненты:

| **Путь**                                 | **Описание**                           |
|-----------------------------------------|----------------------------------------|
| `pom.xml`                               | Конфигурация Maven и зависимости.      |
| `src/main/java/backend/academy/`         | Основной код проекта.                  |
| `│   ├── Main.java`                      | Точка входа в приложение.              |
| `│   └── PerformanceMeasurement/`        | Пакет для измерения производительности. |
| `│       ├── benchmark/`                 | Пакет с бенчмарк-тестами.              |
| `│       │   ├── ReflectionBenchmark.java`| Реализация тестов с JMH.               |
| `│       │   └── BenchmarkResultsCollector.java` | Сбор и анализ результатов тестов.      |
| `│       └── model/`                     | Пакет с моделями данных.               |
| `│           └── Student.java`           | Тестируемый класс.                     |
| `src/test/`                              | Тесты для проверки корректности кода.  |
| `checkstyle.xml`                         | Конфигурация для Checkstyle.           |
| `pmd.xml`                                | Конфигурация для PMD.                  |
| `benchmark_results.txt`                  | Финальные результаты замеров.          |


---

## **Тестируемый класс**

Пример целевого класса:

```java
public record Student(String name, String surname) {}
```

---

## **Бенчмарк-тесты**

Тесты измеряют производительность четырёх методов вызова:

```java
@BenchmarkMode(Mode.AverageTime)
@OutputTimeUnit(TimeUnit.NANOSECONDS)
@State(Scope.Thread)
public class ReflectionBenchmark {
    private Student student;
    private Method method;

    @Setup
    public void setup() throws NoSuchMethodException {
        student = new Student("Alexander", "Biryukov");
        method = Student.class.getDeclaredMethod("name");
        method.setAccessible(true);
    }

    @Benchmark
    public void directAccess(Blackhole bh) {
        bh.consume(student.name());
    }

    @Benchmark
    public void reflectionAccess(Blackhole bh) throws Exception {
        bh.consume(method.invoke(student));
    }
}
```

---

## **Запуск и сборка проекта**

Для запуска и тестирования проекта требуется **Java 22** и **Maven 3.8.8+**.

### **1. Сборка проекта**

Для сборки и проверки корректности выполнения:

```bash
mvn clean verify
```

### **2. Запуск бенчмарк-тестов**

Запуск тестов с помощью JMH:

```bash
mvn exec:java -Dexec.mainClass="backend.academy.PerformanceMeasurement.benchmark.ReflectionBenchmark"
```

### **3. Сбор результатов**

Для сборки и сохранения таблицы с результатами:

```bash
mvn exec:java -Dexec.mainClass="backend.academy.PerformanceMeasurement.benchmark.BenchmarkResultsCollector"
```

Результаты будут сохранены в файл **`benchmark_results.txt`**.

---

## **Пример финальной таблицы результатов**


| **Benchmark**                | **Mode** | **Cnt** | **Score** | **Error** | **Units**  |
|------------------------------|----------|---------|-----------|-----------|-----------|
| directAccess                 | avgt     | 1       | 0.620     | 0.000     | ns/op     |
| lambdaMetafactoryAccess      | avgt     | 1       | 0.907     | 0.000     | ns/op     |
| methodHandleAccess           | avgt     | 1       | 5.108     | 0.000     | ns/op     |
| reflectionAccess             | avgt     | 1       | 7.098     | 0.000     | ns/op     |

---

# **Анализ текущих результатов**

### **# Прямой вызов метода (`directAccess`)**
- **Абсолютный лидер по скорости**: `0.620 ns/op`
- **Причины высокой производительности**:
    - Прямая компиляция кода.
    - Полная оптимизация JIT-компилятором.
    - Отсутствие дополнительных накладных расходов *(например, поиска методов или проверки доступности)*.
- **Эталонный вариант** для сравнительного анализа производительности.

---

### **# ЛямбдаМетафабрика (`lambdaMetafactoryAccess`)**
- **Близок к прямому вызову**: `0.907 ns/op`
- **Преимущества**:
    - Незначительный оверхед относительно прямого вызова.
    - Гибкость при передаче методов *(функциональные интерфейсы создаются во время выполнения)*.
    - Возможность динамического создания функциональных обработчиков.
- **Рекомендация**: оптимальный выбор для сценариев, требующих гибкости и динамичности.

---

### **# Обработчик метода (`methodHandleAccess`)**
- **Медленнее прямого вызова**: `5.108 ns/op`
- **Причины снижения производительности**:
    - Динамическое разрешение метода *(определение адреса во время выполнения)*.
    - Дополнительные проверки типов и доступа перед вызовом.
    - Накладные расходы на поиск и привязку метода.

---

### **# Рефлексия (`reflectionAccess`)**
- **Самый медленный способ вызова**: `7.098 ns/op`
- **Причины низкой производительности**:
    - Динамическое определение и вызов метода.
    - Значительные накладные расходы *(поиск метода, проверки доступа и типов)*.
    - Высокие затраты на выполнение проверок и подготовку вызова.
- **Рекомендация**: избегать использования в производительно-критичных участках кода.

---

# **Многократный запуск тестов**

- Результаты тестов могут **небольшо варьироваться** из-за следующих факторов:
    1. **JIT-компиляция**: JVM оптимизирует код во время выполнения. При повторных запусках производительность может улучшаться.
    2. **Нагрузка на систему**: фоновая активность ОС и других программ влияет на замеры.
    3. **Кэширование данных**: методы и данные могут быть закэшированы, что уменьшает время доступа.

---

# **Практические рекомендации**

- **Для высокопроизводительных участков кода**:  
  Использоваать **прямой вызов методов** для достижения максимальной скорости.

- **LambdaMetafactory**:  
  Хороший **компромисс между производительностью и гибкостью**.

- **Избегайте рефлексии**:  
  В критически важных секциях кода рефлексия имеет высокие накладные расходы и низкую производительность.

---

## **Команды для анализа и тестирования**

1. **Компиляция проекта:**
   ```bash
   mvn compile
   ```

2. **Запуск тестов:**
   ```bash
   mvn test
   ```

3. **Запуск линтеров:**
   ```bash
   mvn checkstyle:check pmd:check spotbugs:check
   ```

4. **Вывод дерева зависимостей:**
   ```bash
   mvn dependency:tree
   ```

---

## **Полезные ресурсы**

- [JMH Samples](https://github.com/openjdk/jmh/tree/master/jmh-samples)
- [Java Reflection](https://blogs.oracle.com/javamagazine/post/java-reflection-introduction)
- [Документация по Maven](https://maven.apache.org/guides/index.html)
- [Java 22 API](https://docs.oracle.com/en/java/javase/22/docs/api/index.html)

---

## **Заключение**

В проекте реализованы и протестированы четыре различных способа вызова методов в Java
с использованием JMH. Результаты замеров производительности позволяют оценить разницу
в скорости и выбрать оптимальный подход для решения задач в реальных проектах.

---
